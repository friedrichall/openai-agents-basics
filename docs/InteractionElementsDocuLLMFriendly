Scope and role of the agent
1.1. This document defines a strict policy for how you must create and modify the file InteractionElements.json for the Vivian framework.
1.2. When the user asks you to create, update, or validate interaction elements, you must follow these instructions exactly.
1.3. When you are explicitly asked to output the contents of InteractionElements.json, you must output only valid JSON, with no explanations or additional text.

File name and location
2.1. You must produce a file named InteractionElements.json.
2.2. You must assume this file is stored in the virtual prototype’s FunctionalSpecification folder.
2.3. You must always structure the content you generate as the complete content of InteractionElements.json, not as a fragment, unless the user explicitly requests a fragment.

Top-level JSON structure
3.1. You must always output a single JSON object with exactly one top-level key: "Elements".
3.2. The value of "Elements" must be an array.
3.3. Each entry in the "Elements" array must be a JSON object describing exactly one interaction element.
3.4. The general structure must be:
3.4.1. {"Elements": [ { ...element 1... }, { ...element 2... } ]}

General rules for interaction elements
4.1. Every element object must contain a "Type" field.
4.2. "Type" must be one of the following strings: "Button", "ToggleButton", "Slider", "Rotatable", "TouchArea", "Movable".
4.3. Every element object must contain a "Name" field.
4.4. "Name" must be a string that uniquely identifies the element within InteractionElements.json.
4.5. You must not create two elements with the same "Name" in the same file.
4.6. You must not add fields to an element that are not described for its type in this policy, unless the user explicitly instructs you to extend the schema and acknowledges that this deviates from the Vivian specification.
4.7. When coordinates or vectors are required, you must use objects with keys "x", "y", and "z", each containing numeric values (for example: 0, 0.0, -0.05).
4.8. When attribute lists are required, you must use an array under the key "InitialAttributeValues", where each entry is an object with keys "Attribute" and "Value".
4.9. When snap poses are required, you must use an array under the key "SnapPoses", where each entry is an object containing at least "Position" and optionally "Rotation", both expressed as strings in the form "(x, y, z)" or "(rx, ry, rz)".

Button configuration ("Type": "Button")
5.1. A Button represents a simple clickable element without persistent state.
5.2. For a Button element, you must include:
5.2.1. "Type" with the value "Button".
5.2.2. "Name" with a unique string identifier.
5.3. You must not add any additional fields to a Button unless explicitly requested.
5.4. Example structure (conceptual):
5.4.1. {"Type": "Button", "Name": "Button_Start"}

ToggleButton configuration ("Type": "ToggleButton")
6.1. A ToggleButton represents a button that retains an on/off state.
6.2. For a ToggleButton element, you must include:
6.2.1. "Type" with the value "ToggleButton".
6.2.2. "Name" with a string identifier.
6.2.3. "InitialAttributeValues" as an array of attribute objects.
6.3. In "InitialAttributeValues" you must include at least one object with:
6.3.1. "Attribute" set to "VALUE".
6.3.2. "Value" set to "true" or "false" (strings) to define the initial on/off state.
6.4. You must not introduce additional attributes for ToggleButton unless explicitly requested.
6.5. Example structure (conceptual):
6.5.1. {"Type": "ToggleButton", "Name": "PowerSwitch", "InitialAttributeValues": [ {"Attribute": "VALUE", "Value": "false"} ]}

Slider configuration ("Type": "Slider")
7.1. A Slider is an element that moves linearly between two positions and represents a numeric value between 0.0 and 1.0 inclusive.
7.2. For a Slider element, you must include:
7.2.1. "Type" with the value "Slider".
7.2.2. "Name" with a string identifier.
7.2.3. "MinPosition" as an object { "x": number, "y": number, "z": number }.
7.2.4. "MaxPosition" as an object { "x": number, "y": number, "z": number }.
7.3. At "MinPosition", the slider’s value corresponds to 0.0.
7.4. At "MaxPosition", the slider’s value corresponds to 1.0.
7.5. You may optionally include "InitialAttributeValues" as an array of attribute objects:
7.5.1. To set the initial value, include an object with "Attribute": "VALUE" and "Value" as a numeric value or numeric string between 0.0 and 1.0 inclusive.
7.5.2. To make the slider initially non-interactive, include an object with "Attribute": "FIXED" and "Value": "true".
7.6. You may optionally include "PositionResolution":
7.6.1. If present, "PositionResolution" must be a positive integer representing the number of discrete positions the slider can take.
7.6.2. If absent, the slider must be treated as having an effectively infinite (continuous) number of positions.
7.7. You may optionally include "TransitionTimeInMs":
7.7.1. If present, "TransitionTimeInMs" must be a non-negative integer representing the time in milliseconds for the slider to transition to a position defined by a state change.
7.8. Example minimal structure (conceptual):
7.8.1. {"Type": "Slider", "Name": "Handle", "MinPosition": {"x": 0.0, "y": 0.0, "z": 0.0}, "MaxPosition": {"x": 0.0, "y": -0.05, "z": 0.0}}

Rotatable configuration ("Type": "Rotatable")
8.1. A Rotatable simulates a knob or hinge rotating around a defined axis, mapping a rotation angle to a value between 0.0 and 1.0.
8.2. The initial rotation of the object in the 3D model is considered 0°.
8.3. For a Rotatable element, you must include:
8.3.1. "Type" with the value "Rotatable".
8.3.2. "Name" with a string identifier.
8.3.3. "MinRotation" as a numeric value in degrees.
8.3.4. "MaxRotation" as a numeric value in degrees.
8.3.5. "RotationAxis" as an object with:
8.3.5.1. "Origin": an object { "x": number, "y": number, "z": number } representing the origin of the rotation axis relative to the rotatable.
8.3.5.2. "Direction": an object { "x": number, "y": number, "z": number } representing the direction of the rotation axis.
8.4. At "MinRotation", the Rotatable value corresponds to 0.0.
8.5. At "MaxRotation", the Rotatable value corresponds to 1.0.
8.6. You may optionally include "InitialAttributeValues" as an array of attribute objects:
8.6.1. To set the initial value, include an object with "Attribute": "VALUE" and "Value" as a numeric value or numeric string between 0.0 and 1.0 inclusive.
8.6.2. To prevent initial user interaction, include an object with "Attribute": "FIXED" and "Value": "true".
8.7. You may optionally include "PositionResolution":
8.7.1. If present, it must be a positive integer specifying the number of discrete rotation positions.
8.7.2. If absent, the rotation must be treated as effectively continuous.
8.8. You may optionally include "AllowsForInfiniteRotation":
8.8.1. If present and set to true, you must ensure that the difference between "MaxRotation" and "MinRotation" is exactly 360.0.
8.8.2. If present and set to false, the rotation must be limited to the [MinRotation, MaxRotation] range.
8.9. You may optionally include "TransitionTimeInMs":
8.9.1. If present, it must be a non-negative integer representing the time in milliseconds for the Rotatable to transition to a new position defined by a state change.
8.10. Example minimal structure (conceptual):
8.10.1. {"Type": "Rotatable", "Name": "RotaryButton", "MinRotation": -90.0, "MaxRotation": 90.0, "RotationAxis": {"Origin": {"x": 0.0, "y": 0.0, "z": 0.0}, "Direction": {"x": 0.0, "y": 0.0, "z": 1.0}}}

TouchArea configuration ("Type": "TouchArea")
9.1. A TouchArea simulates a touch-sensitive surface.
9.2. For a TouchArea element, you must include:
9.2.1. "Type" with the value "TouchArea".
9.2.2. "Name" with a string identifier.
9.2.3. "Plane" as an object { "x": number, "y": number, "z": number } representing the normal vector of the surface relative to the object.
9.2.4. "Resolution" as an object { "x": width, "y": height } where width and height are positive integers in pixels.
9.3. You must not add additional fields to TouchArea unless explicitly requested.
9.4. Example structure (conceptual):
9.4.1. {"Type": "TouchArea", "Name": "Screen", "Plane": {"x": 0, "y": 0, "z": 1}, "Resolution": {"x": 800, "y": 480}}

Movable configuration ("Type": "Movable")
10.1. A Movable represents any object that can move freely to predefined positions (snap poses).
10.2. For a Movable element, you must include:
10.2.1. "Type" with the value "Movable".
10.2.2. "Name" with a string identifier.
10.2.3. "InitialAttributeValues" as an array of attribute objects.
10.2.4. "SnapPoses" as an array of snap pose objects.
10.3. In "InitialAttributeValues" you must include:
10.3.1. At least one object with "Attribute": "POSITION" and "Value" as a string representing the initial position, for example: "(0.1, 3.15, 3.4)".
10.3.2. Optionally, an object with "Attribute": "ROTATION" and "Value" as a string representing Euler angles in degrees, for example: "(0, 25, 25)".
10.4. In "SnapPoses":
10.4.1. Each entry must contain "Position" as a string representing a 3D coordinate, for example: "(-0.73, 4.5, 0.75)".
10.4.2. Each entry may optionally contain "Rotation" as a string of Euler angles, for example: "(0, 25, 25)".
10.5. You may optionally include "TransitionTimeInMs":
10.5.1. If present, it must be a non-negative integer representing how long the Movable transitions from a position close to a snap pose to the exact snap pose.
10.6. Example structure (conceptual):
10.6.1. {"Type": "Movable", "Name": "Cup", "InitialAttributeValues": [ {"Attribute": "POSITION", "Value": "(0.1, 3.15, 3.4)"} ], "SnapPoses": [ {"Position": "(-0.73, 4.5, 0.75)", "Rotation": "(0, 25, 25)"} ]}

Validation rules and conflict handling
11.1. When generating or editing InteractionElements.json, you must ensure that the JSON is syntactically valid.
11.2. You must ensure that the top-level object contains exactly one key "Elements" and that its value is an array.
11.3. You must ensure that every element in "Elements" has a valid "Type" and "Name".
11.4. You must ensure that all required fields for each "Type" are present and correctly formatted.
11.5. You must ensure that numeric ranges and constraints are respected (for example, values between 0.0 and 1.0, positive pixel resolutions, 360° range when "AllowsForInfiniteRotation" is true).
11.6. If user instructions conflict with these rules, you must either:
11.6.1. Adjust the configuration to satisfy the Vivian specification while preserving the user’s intent as closely as possible, and clearly reflect the correct structure in the JSON you output; or
11.6.2. Explain which constraints are violated and propose a corrected configuration that follows this policy, if you are asked to explain instead of outputting pure JSON.
11.7. When the user requests only the JSON file content, you must not include any natural language explanation; you must return only the JSON structure that satisfies all applicable rules in this policy.